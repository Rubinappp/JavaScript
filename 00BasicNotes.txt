"5" + "6" ="56"(concatenation)
5+"6" =11 (Type coercion)
=========================================================
1. early return is nicer than else condition.
function checkAge(age) {
  if (age < 18) {
    return console.log("Too young");
  }
  console.log("You can vote");
}


2. using scope variable with return statement is better than using global variable.
function sum(a, b) {
  const result = a + b;   // local variable
  return result;
}
=========================================================

Truthy and Falsy
Falsy values:False,0,'',NaN ,undefined,null
Truthy values: any value not on falsy values

null= intentionally want stg empty 
undefined= which isnt given value .but we can set default value in case of that 

=========================================================


shortcuts for if-statements 
1 Ternary operator?:
2 Guard operator &&
3 default operator ||
----------------------------------
~.Guard operator example:
   if (false && value2){ 
    console.log("True")
  }
- The left side is already false
- JavaScript does not evaluate the right side
- Execution stops early â†’ this is called   short-circuit evaluation
- Often used as a guard to prevent unnecessary checks

----------------------------------
&& returning a value

  const message= 5 && 'hello'
  console.log(message)
- 5 is truthy
- && returns the last truthy value
- So 'hello' is assigned to message

  This is shortut for..... 
  if(condition){
    console.log('hello')
  }
----------------------------------

~ default operator example:
if (True || value2){ 
    console.log("True")
  }
  if first one is true we already know result is true so js doesn't check right side.
----------------------------------
  const message= 5 || 'hello'
- 5 is truthy
- || returns the first truthy value
- So 'hello' is not used
----------------------------------
const message = 0 || 'hello';
console.log(message); // 'hello'
- 0 is falsy
-'hello' acts as the default value

=========================================================

comparison operator
<,>,>=,<=,===,!== 
== is not used mostly because if string and int is checked with == it will convert int into string. which we dont want


logical operators
&&,||,!
&& > || priority 
=========================================================
order of operations
() ,* / ,+ -, comparison operator,logical operator
=========================================================

Function defination:
helps to reuse code
function Function-name(){

}
=========================================================

Rules for function names:
-No special word like function.
-cant start with number
-can't use special character
-best practice to use camelCase
=========================================================

Rules for parameter names:
-No special word .
-cant start with number
-can't use special character except:$_
=========================================================

We can set default value in parameter.

=========================================================

-object group multiple value together
-let us use multiple value together.
-we have property-value pairs inside object seperated by comma.
-We can use property ,nested object and method inside object .

  const object_name={
    property_name:value,
    [property_name]:value // can only access through bracket notation no dot notation

    nested_object :{
      inner_property:value;
    }

    fun:function functon1(){

    }
  };

Access:
object-name.property_name;
object-name[property_name];

object-name.nested_object ;
object-name.nested_object.inner_property ;

- Bracket notation let us use property that normally dont work with dot notation.

console.log(product.delivery-time) // error
- Here, since - is regarded as substract and it will try to subtract so in that case we need to use bracket.so there are lots of cases bracket are useful instead of dot.

-Function inside object is called method.
console.log = console is object log is method inside that object.

More  built-in objects like console,Math...
1 JSON
2 localstorage

JSON object:
-javascript object notation.
- has similar syntax to js object but  has lesser feature 

JS object               vs          Json 
                                  - all property must use double quotation in json.
                                  - doesn't support function inside.
                                  - can be understood by almost any programming language.
                                  -More universal
                                  - We use json when we want to send data between computer that might be using different languages.
                                  - we use this when we need to store data.

Built-in json object: JSON
- helps to convert js object to json.(JSON.stringify)
- To convert json to js object  (JSON.parse)
js object <->JSON


local storage:
variable are temporary after refresh/close variables are deleted or cleared from memory RAM.
Local storage doesn't delete when refresh.

localstorage only support strings.
localStorage.setItem('name','value')
localStorage.getItem('name')
localStorage.removeItem('name')

class:
const class_name{
  variable_name=value;
}
 

Auto-boxing:Autoboxing is when JavaScript temporarily wraps a primitive value (number, string, boolean, symbol, bigint)
into its corresponding object wrapper so we can access methods and properties.
Eg: "Rubina".length 

- It works with number and string
Eg:0.toString() 
- but wont work with null and undefined.
 Eg: undefined.method() wrong X


object is a reference .
const score = { };
 .The variable score  stores a reference (address) to that object.score is not the object itself.
  Variable = label/tag
  Object = memory block
  Reference = address

Copy by reference:
const object1{
  message:"Hello"
}
const object2=object1; 
-this will copy reference 
-memory eficient and time efficient.

  object1.message="Good Job";
  console.log(message) 
   inspite of const object1 we were able to change the message property since object1 only consist of address of the original object.

   console.log(object1===object2)// It will check the reference True or False

shortcuts:
a.Deconstructing 
const object1={
  message="Hello"
}
const message=object1.message;

if we have same variable and property name.
short cut.....
object1{message}="hello";


b.Short hand property:
if property and value has same name we can do this:
const object1={
  message  // message:message
}


c.Short hand method
const object1={ 
  method:function fun1()
 {console.log("method");}

}
short cut....
const object1={
  method(){
    console.log("method");
  }
}



some built in methods:
Object.keys(obj)     // array of keys
Object.values(obj)  // array of values
Object.entries(obj) // array of [key, value]